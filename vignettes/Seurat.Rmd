---
title: "Using harmony in Seurat"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using harmony in Seurat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE, warning=FALSE}
library(harmony)
```


This tutorial is a short on how to use harmony with Seurat objects. Harmony provides the `RunHarmony()` which is designed to interact with Seurat objects when a some data need to be batch corrected. This workflow will go over some of the basic functionality of Harmony and how the results of harmony can be used for downstream analyses.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(Seurat)
library(dplyr)
library(cowplot)
```

```{r}
## Install latest branch of harmony
## devtools::install_github('immunogenomics/harmony', force = TRUE)
```
# Run Harmony on Seurat Objects
## Genate Seurat Dataset

The files used for this vignette are located under the following zenodo directory https://zenodo.org/record/8164711

```{r}
## Source required data
data("pbmc_stim")
pbmc <- CreateSeuratObject(counts = cbind(stim.sparse, ctrl.sparse), project = "PBMC", min.cells = 5)

## Separate conditions

pbmc@meta.data$stim <- c(rep("STIM", ncol(stim.sparse)), rep("CTRL", ncol(ctrl.sparse)))
```

## Normalize Dataset

After a typical `Seurat::NormalizeData`, we will be generate the union of highly variable genes using each condition. These features are going to be subsequently used to generate the 20 PCs.

```{r}
pbmc <- pbmc %>%
    Seurat::NormalizeData(verbose = FALSE) 


VariableFeatures(pbmc) <- split(row.names(pbmc@meta.data), pbmc@meta.data$stim) %>% lapply(function(cells_use) {
    pbmc[,cells_use] %>%
        FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>% 
        VariableFeatures()
}) %>% unlist %>% unique

pbmc <- pbmc %>% 
    ScaleData(verbose = FALSE) %>% 
    RunPCA(features = VariableFeatures(pbmc), npcs = 20, verbose = FALSE)
```

## Perform an integrated analysis

 The RunHarmony function will integrate datasets defined by the "stim" column in the Seurat Object's metadata:
`pbmc[["stim"]]`
    
 If you want to integrate on another variable, just add that column to the meta.data
 `pbmc[["new_covariate"]] <- my.experimental.covariate`

### Brief overview of the algorithm parameters


![Harmony Algorithm Overview](main.jpg){width=100%}

#### nclust
Under the hood, harmony applies k-means soft-clustering. Therefore, the k needs to be determined. Harmony results and performance are not particularly sensitive for a reasonable range of this parameter value. If this parameter is not set, harmony will autodetermine this based on the dataset size with a maximum cap of 200.

#### theta
Theta is a hyperparameter that controls the aggressiveness of the penalty that harmony applies. By default  `theta=1` with greater values increasing the effect of the penalty and `theta=0` disables harmony's diversity penalty altogether.

#### max.iter.cluster
The maximum number of clustering steps before the integration step, if convergence is not met via the algorithm's convergence criterion. Default value works usually works well and harmony is expected to exit the clustering loop after certain criteria is met. For more information 

#### max.iter.harmony
The maximum number of integration steps if convergence is not met via the algorithm's convergence criterion. Default value works well.

### The convergence plot
The plot below shows the convergence of the Harmony objective function over each iteration of Harmony. Each point is a single cluster step. Different colors represent different Harmony iterations.

```{r, fig.width = 8, fig.height = 6, out.width="100%"}

pbmc <- pbmc %>% 
    RunHarmony("stim", theta = 2, plot_convergence = TRUE, 
               nclust = 50, max.iter.cluster = 20, max.iter.harmony = 10)
```

### Accessing the data
After `RunHarmony` has been successfully executed the Seurat object will have a new reduction entry named **harmony**
```{r}
pbmc@reductions$harmony
```

To access the cell embeddings we can use: `pbmc@reductions$harmony@cell.embeddings`. We can refer to the dimensions either by name or by index:

```{r}
colnames(pbmc@reductions$harmony@cell.embeddings)
```

### Inspection of the modalities
After Harmony integration, cells align along the Harmonized PCs. If they did not, you could increase the *theta* value above and rerun the analysis.

```{r, fig.width = 8, fig.height = 4, out.width="100%", fig.cap="Evaluate harmonization of stim parameter in the harmony generated cell embeddings"}

p1 <- DimPlot(object = pbmc, reduction = "harmony", pt.size = .1, group.by = "stim")
p2 <- VlnPlot(object = pbmc, features = "harmony_1", group.by = "stim",  pt.size = .1)
plot_grid(p1,p2)
```

Plot Genes correlated with the Harmonized PCs

```{r, fig.width = 6, fig.height=6, out.width="100%"}

DimHeatmap(object = pbmc, reduction = "harmony", cells = 500, dims = 1:6)
```

# Using harmony embeddings for dimensionality reduction in Seurat

Similar to the linked vigenette, the harmony results can be used for integrated analysis. You simply need to pass the harmony `reduction` modality name in the method that requires it.

## Perform clustering using the harmonized vectors of cells
```{r}
pbmc <- pbmc %>%
    FindNeighbors(reduction = "harmony") %>%
    FindClusters(resolution = 0.5) 
```
## TSNE dimensionality reduction
```{r, fig.width = 8, fig.height = 4, out.width = "100%", fig.cap="t-SNE Visualization of harmony embeddings"}
pbmc <- pbmc %>%
    RunTSNE(reduction = "harmony")


p1 <- DimPlot(pbmc, reduction = "tsne", group.by = "stim", pt.size = .1)
p2 <- DimPlot(pbmc, reduction = "tsne", label = TRUE, pt.size = .1)
plot_grid(p1, p2)

```

One important observation is to assess that the harmonized data contain biological states of the cells. Therefore by checking the following genes we can see that biological cell states are preserved after harmonization.

```{r, fig.width = 8, fig.height = 10, out.width="100%", fig.cap="Expression of gene panel heatmap in the harmonized PBMC dataset"}
FeaturePlot(object = pbmc, features= c("CD3D", "SELL", "CREM", "CD8A", "GNLY", "CD79A", "FCGR3A", "CCL2", "PPBP"), 
            min.cutoff = "q9", cols = c("lightgrey", "blue"), pt.size = 0.5)

```

## UMAP

Very similarly with TSNE we can run UMAP by passing the harmony reduction in the function.

```{r, fig.width = 8, fig.height=4, out.width="100%", fig.cap="UMAP Visualization of harmony embeddings"}
pbmc <- pbmc %>%
    RunUMAP(reduction = "harmony",  dims = 1:20)

p1 <- DimPlot(pbmc, reduction = "umap", group.by = "stim", pt.size = .1)
p2 <- DimPlot(pbmc, reduction = "umap", label = TRUE,  pt.size = .1)
plot_grid(p1, p2)

```


```{r}
sessionInfo()
```

